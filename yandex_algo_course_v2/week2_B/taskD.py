# В атриуме нового корпуса ФНК урбанисты установили модные гранитные лавочки
# (на которых холодно сидеть зимой и жарко летом).
# Лавочка устроена следующим образом: несколько одинаковых
# кубических гранитных блоков ставятся в ряд,
# а на них кладется гранитная плита.
# При этом блоки располагаются так, чтобы плита не падала:
# для этого достаточно, чтобы и слева, и справа от центра
# плиты был хотя бы один гранитный блок или его часть
# (в частности, если центр плиты приходится
# на середину какого-нибудь блока,
# то и слева, и справа от центра плиты находится часть блока,
# и плита не падает).
# На ФНК много певокурсников
# (но это только пока не произошли отчисления за списывания на курсе ОиМП)
# и им не хватает стульев в аудиториях. Студенты обнаружили,
# что блоки можно использовать в аудитории в качестве сиденья.
# Можно по одному вытаскивать блоки, находящиеся с краю
# (как слева, так и справа).
# Они хотят вытащить из-под лавочки как можно больше блоков так,
# чтобы она при этом не упала (передвигать оставшиеся блоки нельзя).
# Определите, какие блоки они должны оставить.
# Формат ввода

# В первой строке входных данных содержатся два числа:
# L - длина лавочки и K - количество гранитных блоков-ножек.
# Оба числа натуральные и не превышают 10 000.
# Во второй строке следуют K различных целых неотрицательных чисел,
# задающих положение каждой ножки.
# Положение ножки определяется расстоянием от левого края плиты
# до левого края ножки (ножка - это куб размером 1×1×1).
# Ножки перечислены слева направо
# (то есть начиная с ножки с меньшим расстоянием до левого края).
# Формат вывода

# Требуется перечислить ножки, которые студентам нужно оставить.
# Для каждой ножки нужно выдать ее положение, как оно задано во входных данных.
# Ножки следует перечислять слева направо, в том порядке, в котором они встречаются во входных данных.


def find_2_points(L, arr):
    # O(n)
    mid = L / 2
    left_max = arr[-1]
    right_min = arr[0]
    for i, v in enumerate(arr):
        if v < mid:
            left_max = v
            if left_max == int(mid):
                right_min = v
                break

        else:
            right_min = v
            break
    if left_max == right_min:
        return (left_max,)
    else:
        return left_max, right_min


def binsearch(left, right, check, params):
    # ищем последний элемент удовлетворяющий условию
    while left < right:
        mid = (left + right + 1) // 2
        if check(mid, params):
            left = mid
        else:
            right = mid - 1
    return left


def check_l(mid, params):
    L, arr = params
    half_len = L / 2
    return arr[mid] < half_len


def find_closest_points_to_mid(L, arr):
    left_idx = binsearch(0, len(arr) - 1, check_l, (L, arr))
    left_val = arr[left_idx]
    if (left_val == int(L / 2)) and L % 2 != 0:
        return (left_val,)
    else:
        return arr[left_idx], arr[left_idx + 1]


assert find_2_points(3, [0, 1]) == (1,)
assert find_2_points(5, [0, 2]) == (2,)
assert find_2_points(13, [1, 4, 8, 11]) == (4, 8)
assert find_2_points(14, [1, 6, 8, 11, 12, 13]) == (6, 8)
assert find_2_points(4, [0, 1, 2, 3]) == (1, 2)

assert find_closest_points_to_mid(3, [0, 1]) == (1,)
assert find_closest_points_to_mid(5, [0, 2]) == (2,)
assert find_closest_points_to_mid(13, [1, 4, 8, 11]) == (4, 8)
assert find_closest_points_to_mid(14, [1, 6, 8, 11, 12, 13]) == (6, 8)
assert find_closest_points_to_mid(4, [0, 1, 2, 3]) == (1, 2)


L, K = map(int, input().split())
arr = list(map(int, input().split()))


if K < 2:
    raise ValueError(f"len(arr) >=2, current:{len(arr)}")
print(*find_closest_points_to_mid(L, arr))
