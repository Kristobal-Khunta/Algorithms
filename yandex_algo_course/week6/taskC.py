# Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике,
# математике и физике. Так как он был достаточно способным мальчиком и
# усердно учился, то на многих из этих олимпиад он получал дипломы.
# К окончанию школы у него накопилось n дипломов, причём, как оказалось,
# все они имели одинаковые размеры: w — в ширину и h — в высоту.
# Сейчас Петя учится в одном из лучших российских университетов и
# живёт в общежитии со своими одногруппниками.
# Он решил украсить свою комнату,
# повесив на одну из стен свои дипломы за школьные олимпиады.
# Так как к бетонной стене прикрепить дипломы достаточно трудно,
# то он решил купить специальную доску из пробкового дерева,
# чтобы прикрепить её к стене, а к ней — дипломы.
# Для того чтобы эта конструкция выглядела более красиво,
# Петя хочет, чтобы доска была квадратной и
# занимала как можно меньше места на стене.
# Каждый диплом должен быть размещён строго в прямоугольнике размером w на h.
# Дипломы запрещается поворачивать на 90 градусов.
# Прямоугольники, соответствующие различным дипломам,
# не должны иметь общих внутренних точек.
# Требуется написать программу, которая вычислит минимальный размер стороны доски,
#     которая потребуется Пете для размещения всех своих дипломов.


def square_side(w, h, n, n_in_row):
    table_w = w * n_in_row
    n_in_col = n // n_in_row + bool(n % n_in_row)
    table_h = h * n_in_col
    return max(table_h, table_w)


def check_square_side(mid, params):
    # Ищу первый элемент после которого начнется возрастать площадь
    # проверка истина для элементов у которых следующий элемент больше предыдущего
    #  \          /         y- сторона квадрата
    #   \       /
    #     \    /
    #       \/
    # x - число книг в строке
    w, h, n = params
    n_in_row = mid
    side_current = square_side(w, h, n, n_in_row=mid)
    side_next = square_side(w, h, n, n_in_row=mid + 1)
    return side_current < side_next


def binsearch_neig(left, right, check, params):
    # возвращаем мы левый указатель так что для левого и должны проверять включение
    # когда мы передвигаем правый? мы гарантируем что правее ничего интересного нет
    # на сам элемент мы точно не знаем
    while left < right:
        mid = (left + right) // 2
        
        if check(mid, params):
            right = mid
        else:
            left = mid + 1
    return left


def find_min_square_side_len(w, h, n):
    max_elem_in_row = n
    min_num_elem_in_row = 1
    count_in_row = binsearch_neig(min_num_elem_in_row, max_elem_in_row, check_square_side, (w, h, n))
    optimal_side_len = square_side(w, h, n, count_in_row)
    return optimal_side_len

assert find_min_square_side_len(1,1,1)==1
assert find_min_square_side_len(2,3,10)==9
if __name__ == "__main__":
    w, h, n = map(int, input().split())
    optimal_side_len = find_min_square_side_len(w, h, n)
    print(optimal_side_len)
