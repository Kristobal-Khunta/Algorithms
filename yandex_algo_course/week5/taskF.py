# При реализации проекта «Умная школа» было решено в каждый учебный класс выбранной
# для этого школы установить по кондиционеру нового поколения
#  для автоматического охлаждения и вентиляции воздуха.
#  По проекту в каждом классе должен быть установлен только один кондиционер
#   и мощность кондsиционера должна быть достаточной для размеров класса.
#    Чем больше класс, тем мощнее должен быть кондиционер.

# Все классы школы пронумерованы последовательно от 1 до n.
# # Известно, что для каждого класса с номером i, требуется ровно один кондиционер,
# мощность которого больше или равна ai ватт.

# Администрации школы предоставили список из m различных моделей кондиционеров,
# которые можно закупить. Для каждой модели кондиционера известна его мощность и стоимость.
# Требуется написать программу, которая определит, за какую минимальную суммарную
# стоимость кондиционеров можно оснастить все классы школы.

# Формат ввода
# Первая строка входного файла содержит одно целое число n (1 ≤ n ≤ 50 000)
# количество классов в школе.

# Вторая строка содержит n целых чисел ai (1 ≤ ai ≤ 1000) — минимальная мощность
# кондиционера в ваттах, который можно установить в классе с номером i.

# Третья строка содержит одно целое число m (1 ≤ m ≤ 50 000) — количество предложенных
# моделей кондиционеров.

# Далее, в каждой из m строк содержится пара целых чисел bj и cj (1 ≤ bj ≤ 1000, 1 ≤ cj ≤ 1000)
# мощность в ваттах j-й модели кондиционера и его цена в рублях соответственно.

# Формат вывода
# Выходной файл должен содержать одно число минимальную суммарную стоимость
# кондиционеров в рублях. Гарантируется, что хотя бы один корректный выбор кондиционеров существует,
# и во всех классах можно установить подходящий кондиционер.

import math


def min_covered_cost(condicioners, required_powers):
    max_power = 1000
    best_avail_cost_by_power = [-math.inf] + [math.inf] * max_power
    for cond in condicioners:
        cond_power = cond[0]
        cond_cost = cond[1]
        # Если и пока текущий
        while best_avail_cost_by_power[cond_power] > cond_cost:
            best_avail_cost_by_power[cond_power] = cond_cost
            cond_power -= 1
    best_sum = sum([best_avail_cost_by_power[power] for power in required_powers])
    return best_sum


def main():
    n = int(input())
    required_powers = map(int, input().split())
    m = int(input())
    conditioners = [tuple(map(int, input().split())) for _ in range(m)]
    print(min_covered_cost(conditioners, required_powers))


if __name__ == "__main__":
    main()
