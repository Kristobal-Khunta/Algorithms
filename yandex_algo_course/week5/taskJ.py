# Петя достаточно давно занимается в математическом кружке,
# поэтому он уже успел не только правила выполнения простейших операций,
# но и такое достаточно сложное понятие как симметрия.
# Для того, чтобы получше изучить симметрию Петя решил начать
# с наиболее простых геометрических фигур – треугольников.
# Он скоро понял, что осевой симметрией обладают
# так называемые равнобедренные треугольники.
#     Поэтому теперь Петя ищет везде такие треугольники.

# Напомним, что треугольник называется равнобедренным,
# если его площадь положительна, и у него есть хотя бы две равные стороны.

# Недавно Петя, зайдя в класс, увидел, что на доске нарисовано n точек.
# Разумеется, он сразу задумался, сколько существует троек из этих точек,
# которые являются вершинами равнобедренных треугольников.

# Требуется написать программу, решающую указанную задачу.

# Формат ввода
# Входной файл содержит целое число n (3 ≤ n ≤ 1500).
# Каждая из последующих строк содержит по два целых числа
# – xi и yi – координаты i-ой точки. Координаты точек не превосходят
# 109 по абсолютной величине.
# Среди заданных точек нет совпадающих.

# Формат вывода
# В выходной файл выведите ответ на задачу.


from collections import defaultdict


def triangles(points):
    """
    solution from lector https://www.youtube.com/watch?v=fqsuy5rwZhk
    Каждую точку из набора возьмем за "вершину" равнобедренного треугольника
    Для каждой такой точки зафиксируем вторую точку(одно ребро) и
    посчитаем сколькими способами можно выбрать третью точку(второе ребро) такой же длины. 
    Избавимся от вырожденых треугольников. Равносторонний треугольник нельзя 
    построить в целочисленых координатах, о таких вариантах заботиться не надо
    Идеи:
    - Постраемся остаться в целых числах
    - квадрат длины вектора вместо самой длины.
    - проверка на вырожденность x1,y1==-x2,-yx, значит точки на одной прямой и 
    треугольник вырожденный
    - заранее вычитаем из ответа вырожденные треугольники, добавляя обратные координаты
    и сравнивая с ними
        
    
    """
    #
    ans = 0
    n = len(points)
    for i in range(n):
        # i - точка "основатие" от нее отходят равные стороны
        used_vectors = set()
        neigborns = []
        for j in range(n):
            # j - вычислим расстояние от i до каждой другой точки
            vecx = points[i][0] - points[j][0]
            vecy = points[i][1] - points[j][1]
            veclen = vecx ** 2 + vecy ** 2
            neigborns.append(veclen)
            # Проверка на вырожденность треугольника:
            # координаты одной точки == координатам другой точки со знаком минус.
            if (vecx, vecy) in used_vectors:
                ans -= 1
            # добавим обратный вектор в сет
            used_vectors.add((-vecx, -vecy))
        neigborns.sort()
        # [5,5,5,10,10,102,103...]
        # два указателя, r и l
        r = 0
        for l in range(len(neigborns)):
            # для каждого значения длинны, найдем сколько еще таких же значений есть в соседях
            while r < len(neigborns) and neigborns[l] == neigborns[r]:
                r += 1
            ans += r - l - 1
    return ans


def triangles_table(points):
    """
     Stealed from https://github.com/Yankovsky/yandex-algos-training/blob/master/hw5/j.py
    # Рассмотрим точки и матрицу расстояний между ними. будем хранить её именно как массив массивов.
    # Нас интересуют случаи, когда есть одинаковые значения в одной строке –
    # это означает, что от вершины, у которой значение в матрице 0 до двух других вершин одинаковое расстояние,
    # а значит имеем кандидата в равнобедренный треугольник
    # Равнобедренный треугольник невырожденный, если сумма длин его равных сторон больше длины третьей стороны.
    # Эта проверка будет выглядеть так:
    # 2 * длина_равной_стороны > длина_третьей_стороны
    # Через квадраты расстояний:
    # 4 * длина_равной_стороны^2 > длина_третьей_стороны^2
    # Пример:
    # ________|_(0, 0)_|_(1, 1)_|_(0, 1)_|_(1, 0)_|_(0, -1)
    # (0, 0)  | 0      | 2      | 1      | 1      | 1
    # (1, 1)  | 2      | 0      | 1      | 1      | 5
    # (0, 1)  | 1      | 1      | 0      | 2      | 4
    # (1, 0)  | 1      | 1      | 2      | 0      | 2
    # (0, -1) | 1      | 5      | 4      | 2      | 0
    # Идём по строкам сверху вниз, рассматриваем каждую пару одинаковых значений,
    # если такая пара вместе с вершиной 0 образует невырожденный треугольник,
    # то увеличиваем счётчик равнобедренных треугольников.
    # В примере получается, что кандидатов 7, но один является вырожденным ((0, 0) (0, 1) (0, -1)), поэтому ответ 6.
    
    """
    #
    def get_squared_distance(a, b):
        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2

    matrix = [[0] * len(points) for _ in range(len(points))]
    for first_idx, first_point in enumerate(points):
        for second_idx in range(first_idx + 1, len(points)):
            squared_distance = get_squared_distance(first_point, points[second_idx])
            matrix[first_idx][second_idx] = squared_distance
            matrix[second_idx][first_idx] = squared_distance

    triangles_count = 0
    for row in matrix:
        points_by_distances = defaultdict(list)
        for point_idx, squared_distance in enumerate(row):
            point = points[point_idx]
            for previous_point in points_by_distances[squared_distance]:
                if 4 * squared_distance > get_squared_distance(previous_point, point):
                    triangles_count += 1
            points_by_distances[squared_distance].append(point)

    return triangles_count


if __name__ == "__main__":
    n = int(input())
    points = []
    for _ in range(n):
        x, y = map(int, input().split())
        points.append([x, y])

    print(triangles(points))
